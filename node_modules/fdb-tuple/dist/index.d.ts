/// <reference types="node" />
declare type UnboundStamp = {
    data: Buffer;
    stampPos: number;
    codePos?: number;
};
export declare const concat2: (a: Buffer, b: Buffer) => Buffer;
/**
 * Supported tuple item types.
 * This awkwardness brought to you by:
 * https://github.com/unional/typescript-guidelines/blob/master/pages/advance-types/recursive-types.md
 */
export declare type TupleItem = null | Buffer | string | TupleArr | number | BigInt | boolean | {
    type: 'uuid';
    value: Buffer;
} | {
    /**
     * This is flattened into a double during decoding if noCanonicalize is
     * true. NaN has multiple binary encodings and node normalizes NaN to a
     * single binary layout. To preserve the binary representation of NaNs
     * across encoding / decoding, we'll store the original NaN encoding on the
     * object. This is needed for the binding tester to pass.
     */
    type: 'float';
    value: number; /** @deprecated */
    rawEncoding?: Buffer;
} | {
    /** As type: float, although this is only used for noCanonicalize + NaN value. */
    type: 'double';
    value: number; /** @deprecated */
    rawEncoding?: Buffer;
} | {
    type: 'versionstamp';
    value: Buffer;
} | {
    type: 'unbound versionstamp';
    code?: number;
};
interface TupleArr extends Array<TupleItem> {
}
/** This helper only exists because {type: 'unbound versionstamp'} is so awful to type. */
export declare const unboundVersionstamp: (code?: number | undefined) => TupleItem;
/**
 * Begin and end prefixes which contain all tuple children at some key.
 */
export declare const rawRange: {
    begin: Buffer;
    end: Buffer;
};
/**
 * Encode the specified item or array of items into a buffer.
 *
 * pack() and unpack() are the main entrypoints most people will use when using
 * this library.
 *
 * `pack(x)` is equivalent to `pack([x])` if x is not itself an array. Packing
 * single items this way is also slightly more efficient.
 */
export declare const pack: (arr?: string | number | boolean | BigInt | Buffer | TupleArr | {
    type: 'uuid';
    value: Buffer;
} | {
    /**
     * This is flattened into a double during decoding if noCanonicalize is
     * true. NaN has multiple binary encodings and node normalizes NaN to a
     * single binary layout. To preserve the binary representation of NaNs
     * across encoding / decoding, we'll store the original NaN encoding on the
     * object. This is needed for the binding tester to pass.
     */
    type: 'float';
    value: number; /** @deprecated */
    rawEncoding?: Buffer | undefined;
} | {
    /** As type: float, although this is only used for noCanonicalize + NaN value. */
    type: 'double';
    value: number; /** @deprecated */
    rawEncoding?: Buffer | undefined;
} | {
    type: 'versionstamp';
    value: Buffer;
} | {
    type: 'unbound versionstamp';
    code?: number | undefined;
} | TupleItem[] | null | undefined) => Buffer;
/**
 * This variant of pack is used to encode a tuple with an unbound versionstamp
 * inside.
 *
 * It returns the buffer paired with metadata about where inside the returned
 * value the versionstamp should be written.
 *
 * The passed array must, when flattened contain exactly one unbound
 * versionstamp.
 */
export declare const packUnboundVersionstamp: (arr?: string | number | boolean | BigInt | Buffer | TupleArr | {
    type: 'uuid';
    value: Buffer;
} | {
    /**
     * This is flattened into a double during decoding if noCanonicalize is
     * true. NaN has multiple binary encodings and node normalizes NaN to a
     * single binary layout. To preserve the binary representation of NaNs
     * across encoding / decoding, we'll store the original NaN encoding on the
     * object. This is needed for the binding tester to pass.
     */
    type: 'float';
    value: number; /** @deprecated */
    rawEncoding?: Buffer | undefined;
} | {
    /** As type: float, although this is only used for noCanonicalize + NaN value. */
    type: 'double';
    value: number; /** @deprecated */
    rawEncoding?: Buffer | undefined;
} | {
    type: 'versionstamp';
    value: Buffer;
} | {
    type: 'unbound versionstamp';
    code?: number | undefined;
} | TupleItem[] | null | undefined) => UnboundStamp;
export declare const name = "tuple";
/**
 * Unpack a buffer containing a tuple back into its constituent elements.
 *
 * This is the inverse of `pack()`, so unpack(pack(x)) == x.
 *
 * @param buf The buffer containing the tuple data to decode.
 *
 * @param noCanonicalize Pass true here to force the decoder to decode IEEE
 * floatingpoint numbers to `{type:'float' / 'double', val:...}` rather than
 * simply using javascript values. This allows you to tell how a number embedded
 * in a tuple was encoded. Most users will never use this option.
 */
export declare function unpack(buf: Buffer, noCanonicalize?: boolean): TupleItem[];
/**
 * Get the start and end of the range containing all tuples which have the
 * passed tuple as a prefix.
 */
export declare function range(arr: TupleItem | TupleItem[]): {
    begin: Buffer;
    end: Buffer;
};
export declare function bakeVersionstamp(val: TupleItem[], versionstamp: Buffer, codeBytes: Buffer | null): void;
export {};
