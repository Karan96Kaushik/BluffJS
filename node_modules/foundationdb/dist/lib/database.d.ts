/// <reference types="node" />
import * as fdb from './native';
import Transaction, { RangeOptions, Watch } from './transaction';
import { Transformer } from './transformer';
import { NativeValue } from './native';
import { KeySelector } from './keySelector';
import Subspace, { GetSubspace } from './subspace';
import { DatabaseOptions, TransactionOptions, MutationType } from './opts.g';
export declare type WatchWithValue<Value> = Watch & {
    value: Value | undefined;
};
export default class Database<KeyIn = NativeValue, KeyOut = Buffer, ValIn = NativeValue, ValOut = Buffer> {
    _db: fdb.NativeDatabase;
    subspace: Subspace<KeyIn, KeyOut, ValIn, ValOut>;
    constructor(db: fdb.NativeDatabase, subspace: Subspace<KeyIn, KeyOut, ValIn, ValOut>);
    setNativeOptions(opts: DatabaseOptions): void;
    close(): void;
    getRoot(): Database;
    getSubspace(): Subspace<KeyIn, KeyOut, ValIn, ValOut>;
    getPrefix(): Buffer;
    /** Create a shallow reference to the database at a specified subspace */
    at<CKI, CKO, CVI, CVO>(hasSubspace: GetSubspace<CKI, CKO, CVI, CVO>): Database<CKI, CKO, CVI, CVO>;
    /** Create a shallow reference to the database at the subspace of another database reference */
    at(prefix: KeyIn | null): Database<KeyIn, KeyOut, ValIn, ValOut>;
    at<CKI, CKO>(prefix: KeyIn | null, keyXf: Transformer<CKI, CKO>): Database<CKI, CKO, ValIn, ValOut>;
    at<CVI, CVO>(prefix: KeyIn | null, keyXf: undefined, valueXf: Transformer<CVI, CVO>): Database<KeyIn, KeyOut, CVI, CVO>;
    at<CKI, CKO, CVI, CVO>(prefix: KeyIn | null, keyXf: Transformer<CKI, CKO>, valueXf: Transformer<CVI, CVO>): Database<CKI, CKO, CVI, CVO>;
    withKeyEncoding<ChildKeyIn, ChildKeyOut>(keyXf: Transformer<ChildKeyIn, ChildKeyOut>): Database<ChildKeyIn, ChildKeyOut, ValIn, ValOut>;
    withKeyEncoding<NativeValue, Buffer>(): Database<NativeValue, Buffer, ValIn, ValOut>;
    withValueEncoding<ChildValIn, ChildValOut>(valXf: Transformer<ChildValIn, ChildValOut>): Database<KeyIn, KeyOut, ChildValIn, ChildValOut>;
    doTn<T>(body: (tn: Transaction<KeyIn, KeyOut, ValIn, ValOut>) => Promise<T>, opts?: TransactionOptions): Promise<T>;
    doTransaction<T>(body: (tn: Transaction<KeyIn, KeyOut, ValIn, ValOut>) => Promise<T>, opts?: TransactionOptions): Promise<T>;
    doOneshot(body: (tn: Transaction<KeyIn, KeyOut, ValIn, ValOut>) => void, opts?: TransactionOptions): Promise<void>;
    rawCreateTransaction(opts?: TransactionOptions): Transaction<KeyIn, KeyOut, ValIn, ValOut>;
    get(key: KeyIn): Promise<ValOut | undefined>;
    getKey(selector: KeyIn | KeySelector<KeyIn>): Promise<KeyOut | undefined>;
    getVersionstampPrefixedValue(key: KeyIn): Promise<{
        stamp: Buffer;
        value?: ValOut;
    } | null>;
    set(key: KeyIn, value: ValIn): Promise<void>;
    clear(key: KeyIn): Promise<void>;
    clearRange(start: KeyIn, end?: KeyIn): Promise<void>;
    clearRangeStartsWith(prefix: KeyIn): Promise<void>;
    getAndWatch(key: KeyIn): Promise<WatchWithValue<ValOut>>;
    setAndWatch(key: KeyIn, value: ValIn): Promise<Watch>;
    clearAndWatch(key: KeyIn): Promise<Watch>;
    getRangeAll(start: KeyIn | KeySelector<KeyIn>, end?: KeyIn | KeySelector<KeyIn>, opts?: RangeOptions): Promise<[KeyOut, ValOut][]>;
    getRangeAllStartsWith(prefix: KeyIn | KeySelector<KeyIn>, opts?: RangeOptions): Promise<[KeyOut, ValOut][]>;
    atomicOpNative(op: MutationType, key: NativeValue, oper: NativeValue): Promise<void>;
    atomicOp(op: MutationType, key: KeyIn, oper: ValIn): Promise<void>;
    atomicOpKB(op: MutationType, key: KeyIn, oper: Buffer): Promise<void>;
    add(key: KeyIn, oper: ValIn): Promise<void>;
    max(key: KeyIn, oper: ValIn): Promise<void>;
    min(key: KeyIn, oper: ValIn): Promise<void>;
    bitAnd(key: KeyIn, oper: ValIn): Promise<void>;
    bitOr(key: KeyIn, oper: ValIn): Promise<void>;
    bitXor(key: KeyIn, oper: ValIn): Promise<void>;
    bitAndBuf(key: KeyIn, oper: Buffer): Promise<void>;
    bitOrBuf(key: KeyIn, oper: Buffer): Promise<void>;
    bitXorBuf(key: KeyIn, oper: Buffer): Promise<void>;
    byteMin(key: KeyIn, oper: ValIn): Promise<void>;
    byteMax(key: KeyIn, oper: ValIn): Promise<void>;
    setVersionstampedKey(key: KeyIn, value: ValIn, bakeAfterCommit?: boolean): Promise<void>;
    setVersionstampSuffixedKey(key: KeyIn, value: ValIn, suffix?: Buffer): Promise<void>;
    setVersionstampedValue(key: KeyIn, value: ValIn, bakeAfterCommit?: boolean): Promise<void>;
    setVersionstampPrefixedValue(key: KeyIn, value?: ValIn, prefix?: Buffer): Promise<void>;
}
