/// <reference types="node" />
import { Transformer } from "./transformer";
import { NativeValue } from "./native";
export default class Subspace<KeyIn = NativeValue, KeyOut = Buffer, ValIn = NativeValue, ValOut = Buffer> {
    prefix: Buffer;
    keyXf: Transformer<KeyIn, KeyOut>;
    valueXf: Transformer<ValIn, ValOut>;
    _bakedKeyXf: Transformer<KeyIn, KeyOut>;
    constructor(rawPrefix: string | Buffer | null, keyXf?: Transformer<KeyIn, KeyOut>, valueXf?: Transformer<ValIn, ValOut>);
    at(prefix: KeyIn | null): Subspace<KeyIn, KeyOut, ValIn, ValOut>;
    at<CKI, CKO>(prefix: KeyIn | null, keyXf: Transformer<CKI, CKO>): Subspace<CKI, CKO, ValIn, ValOut>;
    at<CVI, CVO>(prefix: KeyIn | null, keyXf: undefined, valueXf: Transformer<CVI, CVO>): Subspace<KeyIn, KeyOut, CVI, CVO>;
    at<CKI, CKO, CVI, CVO>(prefix: KeyIn | null, keyXf?: Transformer<CKI, CKO>, valueXf?: Transformer<CVI, CVO>): Subspace<CKI, CKO, CVI, CVO>;
    /** At a child prefix thats specified without reference to the key transformer */
    atRaw(prefix: Buffer): Subspace<KeyIn, KeyOut, ValIn, ValOut>;
    withKeyEncoding<CKI, CKO>(keyXf: Transformer<CKI, CKO>): Subspace<CKI, CKO, ValIn, ValOut>;
    withValueEncoding<CVI, CVO>(valXf: Transformer<CVI, CVO>): Subspace<KeyIn, KeyOut, CVI, CVO>;
    getSubspace(): this;
    packKey(key: KeyIn): NativeValue;
    unpackKey(key: Buffer): KeyOut;
    packValue(val: ValIn): NativeValue;
    unpackValue(val: Buffer): ValOut;
    packRange(prefix: KeyIn): {
        begin: NativeValue;
        end: NativeValue;
    };
    contains(key: NativeValue): boolean;
}
export declare const root: Subspace;
export interface GetSubspace<KI, KO, VI, VO> {
    getSubspace(): Subspace<KI, KO, VI, VO>;
}
export declare const isGetSubspace: <KI, KO, VI, VO>(obj: any) => obj is GetSubspace<KI, KO, VI, VO>;
