"use strict";
// A subspace is a wrapper around a prefix and key and value transformers. This
// is nearly equivalent to subspaces in the other bindings - the difference is
// it also includes kv transformers, so a subspace here will also automatically
// encode and decode keys and values.
Object.defineProperty(exports, "__esModule", { value: true });
exports.isGetSubspace = exports.root = void 0;
const transformer_1 = require("./transformer");
const util_1 = require("./util");
const EMPTY_BUF = Buffer.alloc(0);
const concatPrefix = (p1, p2) => (p2 == null ? p1
    : p1.length === 0 ? util_1.asBuf(p2)
        : util_1.concat2(p1, util_1.asBuf(p2)));
// Template parameters refer to the types of the allowed key and values you pass
// in to the database (eg in a set(keyin, valin) call) and the types of keys and
// values returned. KeyIn == KeyOut and ValIn == ValOut in almost all cases.
class Subspace {
    constructor(rawPrefix, keyXf, valueXf) {
        this.prefix = rawPrefix != null ? Buffer.from(rawPrefix) : EMPTY_BUF;
        // Ugh typing this is a mess. Usually this will be fine since if you say new
        // Subspace() you'll get the default values for KI/KO/VI/VO.
        this.keyXf = keyXf || transformer_1.defaultTransformer;
        this.valueXf = valueXf || transformer_1.defaultTransformer;
        this._bakedKeyXf = rawPrefix ? transformer_1.prefixTransformer(rawPrefix, this.keyXf) : this.keyXf;
    }
    // ***
    at(prefix, keyXf = this.keyXf, valueXf = this.valueXf) {
        const _prefix = prefix == null ? null : this.keyXf.pack(prefix);
        return new Subspace(concatPrefix(this.prefix, _prefix), keyXf, valueXf);
    }
    /** At a child prefix thats specified without reference to the key transformer */
    atRaw(prefix) {
        return new Subspace(concatPrefix(this.prefix, prefix), this.keyXf, this.valueXf);
    }
    withKeyEncoding(keyXf) {
        return new Subspace(this.prefix, keyXf, this.valueXf);
    }
    withValueEncoding(valXf) {
        return new Subspace(this.prefix, this.keyXf, valXf);
    }
    // GetSubspace implementation
    getSubspace() { return this; }
    // Helpers to inspect whats going on.
    packKey(key) {
        return this._bakedKeyXf.pack(key);
    }
    unpackKey(key) {
        return this._bakedKeyXf.unpack(key);
    }
    packValue(val) {
        return this.valueXf.pack(val);
    }
    unpackValue(val) {
        return this.valueXf.unpack(val);
    }
    packRange(prefix) {
        // if (this._bakedKeyXf.range) return this._bakedKeyXf.range(prefix)
        // else return defaultGetRange(prefix, this._bakedKeyXf)
        return (this._bakedKeyXf.range || transformer_1.defaultGetRange)(prefix, this._bakedKeyXf);
    }
    contains(key) {
        // TODO: This is a little dangerous - we should check if the key exists between this.keyXf.range().
        return util_1.startsWith(util_1.asBuf(key), this.prefix);
    }
}
exports.default = Subspace;
exports.root = new Subspace(null, transformer_1.defaultTransformer, transformer_1.defaultTransformer);
const isGetSubspace = (obj) => {
    return obj != null && typeof obj === 'object' && 'getSubspace' in obj;
};
exports.isGetSubspace = isGetSubspace;
//# sourceMappingURL=subspace.js.map