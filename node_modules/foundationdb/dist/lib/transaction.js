"use strict";
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = require("./error");
const util_1 = require("./util");
const keySelector_1 = require("./keySelector");
const opts_1 = require("./opts");
const opts_g_1 = require("./opts.g");
const versionstamp_1 = require("./versionstamp");
const byteZero = Buffer.alloc(1);
byteZero.writeUInt8(0, 0);
// Polyfill for node < 10.0 to make asyncIterators work (getRange / getRangeBatch).
if (Symbol.asyncIterator == null)
    Symbol.asyncIterator = Symbol.for("Symbol.asyncIterator");
const doNothing = () => { };
/**
 * This class wraps a foundationdb transaction object. All interaction with the
 * data in a foundationdb database happens through a transaction. For more
 * detail about how to model your queries, see the [transaction chapter of the
 * FDB developer
 * guide](https://apple.github.io/foundationdb/developer-guide.html?#transaction-basics).
 *
 * You should never create transactions directly. Instead, open a database and
 * call `await db.doTn(async tn => {...})`.
 *
 * ```javascript
 * const db = fdb.open()
 * const val = await db.doTn(async tn => {
 *   // Use the transaction in this block. The transaction will be automatically
 *   // committed (and potentially retried) after this block returns.
 *   tn.set('favorite color', 'hotpink')
 *   return await tn.get('another key')
 * })
 * ```
 *
 * ---
 *
 * This class has 4 template parameters - which is kind of messy. They're used
 * to make the class typesafe in the face of key and value transformers. These
 * parameters should be automatically inferred, but sometimes you will need to
 * specify them explicitly. They are:
 *
 * @param KeyIn The type for keys passed by the user into functions (eg `get(k:
 * KeyIn)`). Defaults to string | Buffer. Change this by scoping the transaction
 * with a subspace with a key transformer. Eg
 * `txn.at(fdb.root.withKeyEncoding(fdb.tuple)).get([1, 2, 3])`.
 * @param KeyOut The type of keys returned by methods which return keys - like
 * `getKey(..) => Promise<KeyOut?>`. Unless you have a KV transformer, this will
 * be Buffer.
 * @param ValIn The type of values passed into transaction functions, like
 * `txn.set(key, val: ValIn)`. By default this is string | Buffer. Override this
 * by applying a value transformer to your subspace.
 * @param ValOut The type of database values returned by functions. Eg,
 * `txn.get(...) => Promise<ValOut | undefined>`. Defaults to Buffer, but if you
 * apply a value transformer this will change.
 */
class Transaction {
    /**
     * NOTE: Do not call this directly. Instead transactions should be created
     * via db.doTn(...)
     *
     * @internal
     */
    constructor(tn, snapshot, subspace, 
    // keyEncoding: Transformer<KeyIn, KeyOut>, valueEncoding: Transformer<ValIn, ValOut>,
    opts, ctx) {
        this._tn = tn;
        this.isSnapshot = snapshot;
        this.subspace = subspace;
        this._keyEncoding = subspace._bakedKeyXf;
        this._valueEncoding = subspace.valueXf;
        // this._root = root || this
        if (opts)
            opts_1.eachOption(opts_g_1.transactionOptionData, opts, (code, val) => tn.setOption(code, val));
        this._ctx = ctx ? ctx : {
            nextCode: 0,
            toBake: null
        };
    }
    // Internal method to actually run a transaction retry loop. Do not call
    // this directly - instead use Database.doTn().
    /** @internal */
    async _exec(body, opts) {
        // Logic described here:
        // https://apple.github.io/foundationdb/api-c.html#c.fdb_transaction_on_error
        do {
            try {
                const result = await body(this);
                const stampPromise = (this._ctx.toBake && this._ctx.toBake.length)
                    ? this.getVersionstamp() : null;
                await this.rawCommit();
                if (stampPromise) {
                    const stamp = await stampPromise.promise;
                    this._ctx.toBake.forEach(({ item, transformer, code }) => (transformer.bakeVersionstamp(item, stamp, code)));
                }
                return result; // Ok, success.
            }
            catch (err) {
                // See if we can retry the transaction
                if (err instanceof error_1.default) {
                    await this.rawOnError(err.code); // If this throws, punt error to caller.
                    // If that passed, loop.
                }
                else
                    throw err;
            }
            // Reset our local state that will have been filled in by calling the body.
            this._ctx.nextCode = 0;
            if (this._ctx.toBake)
                this._ctx.toBake.length = 0;
        } while (true);
    }
    /**
     * Set options on the transaction object. These options can have a variety of
     * effects - see TransactionOptionCode for details. For options which are
     * persistent on the transaction, its recommended to set the option when the
     * transaction is constructed.
     *
     * Note that options are shared between a transaction object and any aliases
     * of the transaction object (eg in other scopes or from `txn.snapshot()`).
     */
    setOption(opt, value) {
        // TODO: Check type of passed option is valid.
        this._tn.setOption(opt, (value == null) ? null : value);
    }
    /**
     * Returns a shallow copy of the transaction object which does snapshot reads.
     */
    snapshot() {
        return new Transaction(this._tn, true, this.subspace, undefined, this._ctx);
    }
    /**
     * Create a shallow copy of the transaction in the specified subspace (or database, transaction, or directory).
    */
    at(hasSubspace) {
        return new Transaction(this._tn, this.isSnapshot, hasSubspace.getSubspace(), undefined, this._ctx);
    }
    /** @deprecated - use transaction.at(db) instead. */
    scopedTo(db) {
        return this.at(db);
    }
    /** Get the current subspace */
    getSubspace() { return this.subspace; }
    rawCommit(cb) {
        return cb
            ? this._tn.commit(cb)
            : this._tn.commit();
    }
    rawReset() { this._tn.reset(); }
    rawCancel() { this._tn.cancel(); }
    rawOnError(code, cb) {
        return cb
            ? this._tn.onError(code, cb)
            : this._tn.onError(code);
    }
    get(key, cb) {
        const keyBuf = this._keyEncoding.pack(key);
        return cb
            ? this._tn.get(keyBuf, this.isSnapshot, (err, val) => {
                cb(err, val == null ? undefined : this._valueEncoding.unpack(val));
            })
            : this._tn.get(keyBuf, this.isSnapshot)
                .then(val => val == null ? undefined : this._valueEncoding.unpack(val));
    }
    /** Checks if the key exists in the database. This is just a shorthand for
     * tn.get() !== undefined.
     */
    exists(key) {
        const keyBuf = this._keyEncoding.pack(key);
        return this._tn.get(keyBuf, this.isSnapshot).then(val => val != undefined);
    }
    /**
     * Find and return the first key which matches the specified key selector
     * inside the given subspace. Returns undefined if no key matching the
     * selector falls inside the current subspace.
     *
     * If you pass a key instead of a selector, this method will find the first
     * key >= the specified key. Aka `getKey(someKey)` is the equivalent of
     * `getKey(keySelector.firstGreaterOrEqual(somekey))`.
     *
     * Note that this method is a little funky in the root subspace:
     *
     * - We cannot differentiate between "no smaller key found" and "found the
     *   empty key ('')". To make the API more consistent, we assume you aren't
     *   using the empty key in your dataset.
     * - If your key selector looks forward in the dataset, this method may find
     *   and return keys in the system portion (starting with '\xff').
     */
    getKey(_sel) {
        const sel = keySelector_1.default.from(_sel);
        return this._tn.getKey(this._keyEncoding.pack(sel.key), sel.orEqual, sel.offset, this.isSnapshot)
            .then(key => ((key.length === 0 || !this.subspace.contains(key))
            ? undefined
            : this._keyEncoding.unpack(key)));
    }
    /** Set the specified key/value pair in the database */
    set(key, val) {
        this._tn.set(this._keyEncoding.pack(key), this._valueEncoding.pack(val));
    }
    /** Remove the value for the specified key */
    clear(key) {
        const pack = this._keyEncoding.pack(key);
        this._tn.clear(pack);
    }
    /** Alias for `tn.clear()` to match semantics of javascripts Map/Set/etc classes */
    delete(key) {
        return this.clear(key);
    }
    // This just destructively edits the result in-place.
    _encodeRangeResult(r) {
        // This is slightly faster but I have to throw away the TS checks in the process. :/
        for (let i = 0; i < r.length; i++) {
            ;
            r[i][0] = this._keyEncoding.unpack(r[i][0]);
            r[i][1] = this._valueEncoding.unpack(r[i][1]);
        }
        return r;
    }
    getRangeNative(start, end, // If not specified, start is used as a prefix.
    limit, targetBytes, streamingMode, iter, reverse) {
        const _end = end != null ? end : keySelector_1.default.firstGreaterOrEqual(util_1.strInc(start.key));
        return this._tn.getRange(start.key, start.orEqual, start.offset, _end.key, _end.orEqual, _end.offset, limit, targetBytes, streamingMode, iter, this.isSnapshot, reverse);
    }
    getRangeRaw(start, end, limit, targetBytes, streamingMode, iter, reverse) {
        return this.getRangeNative(keySelector_1.default.toNative(start, this._keyEncoding), end != null ? keySelector_1.default.toNative(end, this._keyEncoding) : null, limit, targetBytes, streamingMode, iter, reverse)
            .then(r => ({ more: r.more, results: this._encodeRangeResult(r.results) }));
    }
    /**
     * This method is functionally the same as *getRange*, but values are returned
     * in the batches they're delivered in from the database. This method is
     * present because it may be marginally faster than `getRange`.
     *
     * Example:
     *
     * ```
     * for await (const batch of tn.getRangeBatch(0, 1000)) {
     *   for (let k = 0; k < batch.length; k++) {
     *     const [key, val] = batch[k]
     *     // ...
     *   }
     * }
     * ```
     *
     * @see Transaction.getRange
     */
    getRangeBatch(_start, // Consider also supporting string / buffers for these.
    _end, // If not specified, start is used as a prefix.
    opts = {}) {
        return __asyncGenerator(this, arguments, function* getRangeBatch_1() {
            // This is a bit of a dog's breakfast. We're trying to handle a lot of different cases here:
            // - The start and end parameters can be specified as keys or as selectors
            // - The end parameter can be missing / null, and if it is we want to "do the right thing" here
            //   - Which normally means searching between [start, strInc(start)]
            //   - But with tuple encoding this means between [start + '\x00', start + '\xff']
            let start, end;
            const startSelEnc = keySelector_1.default.from(_start);
            if (_end == null) {
                const range = this.subspace.packRange(startSelEnc.key);
                start = keySelector_1.default(range.begin, startSelEnc.orEqual, startSelEnc.offset);
                end = keySelector_1.default.firstGreaterOrEqual(range.end);
            }
            else {
                start = keySelector_1.default.toNative(startSelEnc, this._keyEncoding);
                end = keySelector_1.default.toNative(keySelector_1.default.from(_end), this._keyEncoding);
            }
            let limit = opts.limit || 0;
            const streamingMode = opts.streamingMode == null ? opts_g_1.StreamingMode.Iterator : opts.streamingMode;
            let iter = 0;
            while (1) {
                const { results, more } = yield __await(this.getRangeNative(start, end, limit, 0, streamingMode, ++iter, opts.reverse || false));
                if (results.length) {
                    if (!opts.reverse)
                        start = keySelector_1.default.firstGreaterThan(results[results.length - 1][0]);
                    else
                        end = keySelector_1.default.firstGreaterOrEqual(results[results.length - 1][0]);
                }
                // This destructively consumes results.
                yield yield __await(this._encodeRangeResult(results));
                if (!more)
                    break;
                if (limit) {
                    limit -= results.length;
                    if (limit <= 0)
                        break;
                }
            }
        });
    }
    // TODO: getRangeBatchStartsWith
    /**
     * Get all key value pairs within the specified range. This method returns an
     * async generator, which can be iterated over in a `for await(...)` loop like
     * this:
     *
     * ```
     * for await (const [key, value] of tn.getRange('a', 'z')) {
     *  // ...
     * }
     * ```
     *
     * The values will be streamed from the database as they are read.
     *
     * Key value pairs will be yielded in the order they are present in the
     * database - from lowest to highest key. (Or the reverse order if
     * `reverse:true` is set in options).
     *
     * Note that transactions are [designed to be short
     * lived](https://apple.github.io/foundationdb/developer-guide.html?#long-running-transactions),
     * and will error if the read operation takes more than 5 seconds.
     *
     * The end of the range is optional. If missing, this method will use the
     * first parameter as a prefix and fetch all key value pairs starting with
     * that key.
     *
     * The start or the end can be specified using KeySelectors instead of raw
     * keys in order to specify offsets and such.
     *
     * getRange also takes an optional extra options object parameter. Valid
     * options are:
     *
     * - **limit:** (number) Maximum number of items returned by the call to
     *   getRange
     * - **reverse:** (boolean) Flag to reverse the iteration, and instead search
     *   from `end` to `start`. Key value pairs will be returned from highest key
     *   to lowest key.
     * - **streamingMode:** (enum StreamingMode) *(rarely used)* The policy for
     *   how eager FDB should be about prefetching data. See enum StreamingMode in
     *   opts.
     */
    getRange(start, // Consider also supporting string / buffers for these.
    end, opts) {
        return __asyncGenerator(this, arguments, function* getRange_1() {
            var e_1, _a;
            try {
                for (var _b = __asyncValues(this.getRangeBatch(start, end, opts)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const batch = _c.value;
                    for (const pair of batch)
                        yield yield __await(pair);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    // TODO: getRangeStartsWtih
    /**
     * Same as getRange, but prefetches and returns all values in an array rather
     * than streaming the values over the wire. This is often more convenient, and
     * makes sense when dealing with a small range.
     *
     * @see Transaction.getRange
     *
     * @returns array of [key, value] pairs
     */
    async getRangeAll(start, end, // if undefined, start is used as a prefix.
    opts = {}) {
        var e_2, _a;
        const childOpts = Object.assign({}, opts);
        if (childOpts.streamingMode == null)
            childOpts.streamingMode = opts_g_1.StreamingMode.WantAll;
        const result = [];
        try {
            for (var _b = __asyncValues(this.getRangeBatch(start, end, childOpts)), _c; _c = await _b.next(), !_c.done;) {
                const batch = _c.value;
                result.push.apply(result, batch);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return result;
    }
    getRangeAllStartsWith(prefix, opts) {
        return this.getRangeAll(prefix, undefined, opts);
    }
    /**
     * Removes all key value pairs from the database in between start and end.
     *
     * End parameter is optional. If not specified, this removes all keys with
     * *start* as a prefix.
     */
    clearRange(_start, _end) {
        let start, end;
        // const _start = this._keyEncoding.pack(start)
        if (_end == null) {
            const range = this.subspace.packRange(_start);
            start = range.begin;
            end = range.end;
        }
        else {
            start = this._keyEncoding.pack(_start);
            end = this._keyEncoding.pack(_end);
        }
        // const _end = end == null ? strInc(_start) : this._keyEncoding.pack(end)
        this._tn.clearRange(start, end);
    }
    /** An alias for unary clearRange */
    clearRangeStartsWith(prefix) {
        this.clearRange(prefix);
    }
    watch(key, opts) {
        const throwAll = opts && opts.throwAllErrors;
        const watch = this._tn.watch(this._keyEncoding.pack(key), !throwAll);
        // Suppress the global unhandledRejection handler when a watch errors
        watch.promise.catch(doNothing);
        return watch;
    }
    addReadConflictRange(start, end) {
        this._tn.addReadConflictRange(this._keyEncoding.pack(start), this._keyEncoding.pack(end));
    }
    addReadConflictKey(key) {
        const keyBuf = this._keyEncoding.pack(key);
        this._tn.addReadConflictRange(keyBuf, util_1.strNext(keyBuf));
    }
    addWriteConflictRange(start, end) {
        this._tn.addWriteConflictRange(this._keyEncoding.pack(start), this._keyEncoding.pack(end));
    }
    addWriteConflictKey(key) {
        const keyBuf = this._keyEncoding.pack(key);
        this._tn.addWriteConflictRange(keyBuf, util_1.strNext(keyBuf));
    }
    // version must be 8 bytes
    setReadVersion(v) { this._tn.setReadVersion(v); }
    getReadVersion(cb) {
        return cb ? this._tn.getReadVersion(cb) : this._tn.getReadVersion();
    }
    getCommittedVersion() { return this._tn.getCommittedVersion(); }
    getVersionstamp(cb) {
        if (cb)
            return this._tn.getVersionstamp(cb);
        else {
            // This one is surprisingly tricky:
            //
            // - If we return the promise as normal, you'll deadlock if you try to
            //   return it via your async tn function (since JS automatically
            //   flatmaps promises)
            // - Also if the tn conflicts, this promise will also generate an error.
            //   By default node will crash your program when it sees this error.
            //   We'll allow the error naturally, but suppress node's default
            //   response by adding an empty catch function
            const promise = this._tn.getVersionstamp();
            promise.catch(doNothing);
            return { promise };
        }
    }
    getAddressesForKey(key) {
        return this._tn.getAddressesForKey(this._keyEncoding.pack(key));
    }
    // **** Atomic operations
    atomicOpNative(opType, key, oper) {
        this._tn.atomicOp(opType, key, oper);
    }
    atomicOpKB(opType, key, oper) {
        this._tn.atomicOp(opType, this._keyEncoding.pack(key), oper);
    }
    atomicOp(opType, key, oper) {
        this._tn.atomicOp(opType, this._keyEncoding.pack(key), this._valueEncoding.pack(oper));
    }
    /**
     * Does little-endian addition on encoded values. Value transformer should encode to some
     * little endian type.
     */
    add(key, oper) { this.atomicOp(opts_g_1.MutationType.Add, key, oper); }
    max(key, oper) { this.atomicOp(opts_g_1.MutationType.Max, key, oper); }
    min(key, oper) { this.atomicOp(opts_g_1.MutationType.Min, key, oper); }
    // Raw buffer variants are provided here to support fancy bit packing semantics.
    bitAnd(key, oper) { this.atomicOp(opts_g_1.MutationType.BitAnd, key, oper); }
    bitOr(key, oper) { this.atomicOp(opts_g_1.MutationType.BitOr, key, oper); }
    bitXor(key, oper) { this.atomicOp(opts_g_1.MutationType.BitXor, key, oper); }
    bitAndBuf(key, oper) { this.atomicOpKB(opts_g_1.MutationType.BitAnd, key, oper); }
    bitOrBuf(key, oper) { this.atomicOpKB(opts_g_1.MutationType.BitOr, key, oper); }
    bitXorBuf(key, oper) { this.atomicOpKB(opts_g_1.MutationType.BitXor, key, oper); }
    /*
     * Performs lexicographic comparison of byte strings. Sets the value in the
     * database to the lexographical min of its current value and the value
     * supplied as a parameter. If the key does not exist in the database this is
     * the same as set().
     */
    byteMin(key, val) { this.atomicOp(opts_g_1.MutationType.ByteMin, key, val); }
    /*
     * Performs lexicographic comparison of byte strings. Sets the value in the
     * database to the lexographical max of its current value and the value
     * supplied as a parameter. If the key does not exist in the database this is
     * the same as set().
     */
    byteMax(key, val) { this.atomicOp(opts_g_1.MutationType.ByteMax, key, val); }
    // **** Version stamp stuff
    getNextTransactionID() { return this._ctx.nextCode++; }
    _bakeCode(into) {
        if (this.isSnapshot)
            throw new Error('Cannot use this method in a snapshot transaction');
        if (into.codePos != null) {
            // We edit the buffer in-place but leave the codepos as is so if the txn
            // retries it'll overwrite the code.
            const id = this.getNextTransactionID();
            if (id > 0xffff)
                throw new Error('Cannot use more than 65536 unique versionstamps in a single transaction. Either split your writes into multiple transactions or add explicit codes to your unbound versionstamps');
            into.data.writeInt16BE(id, into.codePos);
            return into.data.slice(into.codePos, into.codePos + 2);
        }
        return null;
    }
    setVersionstampedKeyRaw(keyBytes, value) {
        this.atomicOpNative(opts_g_1.MutationType.SetVersionstampedKey, keyBytes, this._valueEncoding.pack(value));
    }
    // This sets the key [prefix, 10 bytes versionstamp, suffix] to value.
    setVersionstampedKeyBuf(prefix, suffix, value) {
        const key = versionstamp_1.packVersionstampPrefixSuffix(prefix, suffix, true);
        // console.log('key', key)
        this.atomicOpNative(opts_g_1.MutationType.SetVersionstampedKey, key, this._valueEncoding.pack(value));
    }
    _addBakeItem(item, transformer, code) {
        if (transformer.bakeVersionstamp) {
            const scope = this._ctx;
            if (scope.toBake == null)
                scope.toBake = [];
            scope.toBake.push({ item, transformer, code });
        }
    }
    // TODO: These method names are a bit confusing.
    // 
    // The short version is, if you're using the tuple type with an unbound
    // versionstamp, use setVersionstampedKey. Otherwise if you just want your
    // key to be baked out with a versionstamp after it, use
    // setVersionstampSuffixedKey.
    setVersionstampedKey(key, value, bakeAfterCommit = true) {
        if (!this._keyEncoding.packUnboundVersionstamp) {
            throw TypeError('Key encoding does not support unbound versionstamps. Use setVersionstampPrefixedValue instead');
        }
        const pack = this._keyEncoding.packUnboundVersionstamp(key);
        const code = this._bakeCode(pack);
        this.setVersionstampedKeyRaw(versionstamp_1.packVersionstamp(pack, true), value);
        if (bakeAfterCommit)
            this._addBakeItem(key, this._keyEncoding, code);
    }
    setVersionstampSuffixedKey(key, value, suffix) {
        const prefix = util_1.asBuf(this._keyEncoding.pack(key));
        this.setVersionstampedKeyBuf(prefix, suffix, value);
    }
    // Ok now versionstamped values
    setVersionstampedValueRaw(key, value) {
        this.atomicOpKB(opts_g_1.MutationType.SetVersionstampedValue, key, value);
    }
    setVersionstampedValue(key, value, bakeAfterCommit = true) {
        // This is super similar to setVersionstampedKey. I wish I could reuse the code.
        if (!this._valueEncoding.packUnboundVersionstamp) {
            throw TypeError('Value encoding does not support unbound versionstamps. Use setVersionstampPrefixedValue instead');
        }
        const pack = this._valueEncoding.packUnboundVersionstamp(value);
        const code = this._bakeCode(pack);
        this.setVersionstampedValueRaw(key, versionstamp_1.packVersionstamp(pack, false));
        if (bakeAfterCommit)
            this._addBakeItem(value, this._valueEncoding, code);
    }
    /**
     * Set key = [10 byte versionstamp, value in bytes]. This function leans on
     * the value transformer to pack & unpack versionstamps. An extra value
     * prefix is only supported on API version 520+.
     */
    setVersionstampPrefixedValue(key, value, prefix) {
        const valBuf = value !== undefined ? util_1.asBuf(this._valueEncoding.pack(value)) : undefined;
        const val = versionstamp_1.packVersionstampPrefixSuffix(prefix, valBuf, false);
        this.atomicOpKB(opts_g_1.MutationType.SetVersionstampedValue, key, val);
    }
    /**
     * Helper to get the specified key and split out the stamp and value pair.
     * This requires that the stamp is at offset 0 (the start) of the value.
     * This is designed to work with setVersionstampPrefixedValue. If you're
     * using setVersionstampedValue with tuples, just call get().
     */
    async getVersionstampPrefixedValue(key) {
        const val = await this._tn.get(this._keyEncoding.pack(key), this.isSnapshot);
        return val == null ? null
            : {
                stamp: val.slice(0, 10),
                // So this is a bit opinionated - if you call
                // setVersionstampPrefixedValue with no value, the db will just have
                // the 10 byte versionstamp. So when you get here, we have no bytes
                // for the decoder and that can cause issues. We'll just return null
                // in that case - but, yeah, controversial. You might want some other
                // encoding or something. File an issue if this causes you grief.
                value: val.length > 10 ? this._valueEncoding.unpack(val.slice(10)) : undefined
            };
    }
    getApproximateSize() {
        return this._tn.getApproximateSize();
    }
}
exports.default = Transaction;
//# sourceMappingURL=transaction.js.map