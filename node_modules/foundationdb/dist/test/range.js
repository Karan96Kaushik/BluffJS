"use strict";
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
require("mocha");
const fdb = require("../lib");
const assert = require("assert");
const util_1 = require("./util");
util_1.withEachDb(db => describe('key value functionality', () => {
    const batchToStrUnprefix = (batch) => (batch.map(([k, v]) => [k.toString(), v.toString()]));
    const prefill = async () => {
        const _db = db.at(null, util_1.numXF, util_1.numXF);
        await _db.doTransaction(async (tn) => {
            for (let i = 0; i < 100; i++)
                tn.set(i, i);
        });
        return _db;
    };
    it('returns all values through getRange iteration', async () => {
        const _db = await prefill();
        await _db.doTransaction(async (tn) => {
            var e_1, _a;
            let i = 0;
            try {
                for (var _b = __asyncValues(tn.getRange(0, 1000)), _c; _c = await _b.next(), !_c.done;) {
                    const [key, val] = _c.value;
                    assert.strictEqual(key, i);
                    assert.strictEqual(val, i);
                    i++;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            assert.strictEqual(i, 100);
        });
    });
    it('can correctly reverse the range query', async () => {
        const _db = await prefill();
        await _db.doTransaction(async (tn) => {
            var e_2, _a;
            let i = 100;
            try {
                for (var _b = __asyncValues(tn.getRange(0, 1000, { reverse: true })), _c; _c = await _b.next(), !_c.done;) {
                    const [key, val] = _c.value;
                    i--;
                    assert.strictEqual(key, i);
                    assert.strictEqual(val, i);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            assert.strictEqual(i, 0);
        });
    });
    it('returns all values through getRangeBatch', async () => {
        const _db = await prefill();
        await _db.doTransaction(async (tn) => {
            var e_3, _a;
            let i = 0;
            try {
                for (var _b = __asyncValues(tn.getRangeBatch(0, 1000)), _c; _c = await _b.next(), !_c.done;) {
                    const batch = _c.value;
                    for (let k = 0; k < batch.length; k++) {
                        const [key, val] = batch[k];
                        assert.strictEqual(key, i);
                        assert.strictEqual(val, i);
                        i++;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            assert.strictEqual(i, 100);
        });
    });
    it('supports raw string ranges against the root database', async () => {
        // Regression - https://github.com/josephg/node-foundationdb/pull/39
        // This regression requires that we run a naked query without a prefix,
        // which is difficult to do with the current API
        await db.getRoot().doTransaction(async (tn) => {
            var e_4, _a;
            try {
                for (var _b = __asyncValues(tn.getRange('a', 'b')), _c; _c = await _b.next(), !_c.done;) {
                    const batch = _c.value;
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    });
    it('fetches tuple ranges using a prefix correctly', async () => {
        const _db = db.withKeyEncoding(fdb.tuple);
        await _db.set(['a\x00'], 'no');
        await _db.set(['a', 'b'], 'yes');
        assert.deepStrictEqual(await _db.getRangeAllStartsWith(['a']), [[['a', 'b'], Buffer.from('yes')]]);
    });
    it('clears tuple ranges using a prefix correctly', async () => {
        const _db = db.withKeyEncoding(fdb.tuple);
        await _db.set(['a\x00'], 'no');
        await _db.set(['a', 'b'], 'yes');
        await _db.clearRangeStartsWith('a');
        // That should have deleted yes, but not no.
        assert.equal(await _db.get(['a', 'b']), null);
        assert.deepStrictEqual(await _db.get(['a\x00']), Buffer.from('no'));
    });
    it('getRange without a specified end uses start as a prefix');
    describe('selectors', () => {
        const data = [['a', 'A'], ['b', 'B'], ['c', 'C']];
        beforeEach(async () => {
            await db.doTransaction(async (tn) => {
                data.forEach(([k, v]) => tn.set(k, v));
            });
        });
        it('raw string range queries get [start,end)', async () => {
            const result = batchToStrUnprefix(await db.getRangeAll('a', 'c'));
            assert.deepEqual(result, data.slice(0, 2)); // 'a', 'b'.
        });
        it('returns [start, end) with firstGreaterThanEq selectors', async () => {
            const result = batchToStrUnprefix(await db.getRangeAll(fdb.keySelector.firstGreaterOrEqual('a'), fdb.keySelector.firstGreaterOrEqual('c')));
            assert.deepEqual(result, data.slice(0, 2)); // 'a', 'b'.
        });
        it('returns (start, end] with firstGreaterThan selectors', async () => {
            const result = batchToStrUnprefix(await db.getRangeAll(fdb.keySelector.firstGreaterThan('a'), fdb.keySelector.firstGreaterThan('c')));
            assert.deepEqual(result, data.slice(1)); // 'b', 'c'.
        });
    });
}));
//# sourceMappingURL=range.js.map